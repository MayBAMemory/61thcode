>```C
>验证匿名管道的性质：
>1、是否发生读阻塞？
>2、是否发生写阻塞？
>3、读端先关闭，写端继续写会怎么样？
>4、写端先关闭，读端继续读会怎么样？
>```
>
>```C
>// 当匿名的管道的读端和写端都存在: 缓冲区无数据可读, 发生读阻塞
>// 当匿名的管道的读端和写端都存在: 缓冲区写满, 发生写阻塞
>  // 读端先关闭，写端继续写会触发sigpipe信号, 导致进程终止
>    // 写端先关闭，读端继续读数据的时候, 缓冲区有数据则可以继续读, 缓冲区无数据则read函数不会阻塞直接返回0
>     ```

>```C
>新建共享内存，连接，然后往共享内存写入How are you,然后另外一个进程连接共享内存，读取数据并打印显示,最后删除共享内存。提交操作记录和相关代码。
>```
>
>```C
>int main(){
>
>    key_t key_id = ftok("./01_test", 10);
>    int shmid = shmget(key_id, 4096, 0600|IPC_CREAT);
>
>    void * p = shmat(shmid, NULL, 0);
>    strcpy((char *)p, "How are you");
>
>    return 0;
>}
>```
>
>```c
>int main(){
>    
>    key_t key_id = ftok("./01_test", 10);
>    int shmid = shmget(key_id, 4096, 0600|IPC_CREAT);
>
>    void * p = shmat(shmid, NULL, 0);
>    printf("str: %s \n", (char *)p);
>    shmdt(p);
>    
>    shmctl(shmid,IPC_RMID,NULL);
>    return 0;
>}
>```
>

>```C
>fork创建一个子进程，两个进程访问同一段共享内存，共享内存里保存一个整形数，父子进程用for循环的方式。每次对这个整形数字加1，父子进程各循环1000万次。加完后打印一下共享内存里的数字，看看是多少？
>```
>
>```C
>int main(int argc,char*argv[])
>{
>    int shmid = shmget(100, 4096, 0600|IPC_CREAT);
>    int *p = (int *)shmat(shmid, NULL, 0);
>    p[0] = 0;
>
>    if(fork() == 0){
>       for(int i = 0; i < 10000000; i++){
>           p[0]++;
>       }
>    }else{
>       for(int i = 0; i < 10000000; i++){
>           p[0]++;
>       }
>
>       wait(NULL);
>       printf("%d \n", p[0]);
>    }
>    return 0;
>}
>```

>```C
>signal的作用是什么？会不会导致阻塞？handler函数会在什么情况下调用？使用同一个handler去注册不同的信号，效果怎么样？
>```
>
>```C
>// signal的函数的作用是注册信号的处理行为:
>// 我们可以通过signal函数把某一个可注册行为信号的信号处理模式改为:
>//		1, 改为忽略: signal(信号宏/信号值, SIG_IGN)
>//		2, 改为默认处理模式: signal(信号宏/信号值, SIG_DFL)
>//		3, 改为执行某些信号处理函数:  signal(信号宏/信号值, 函数名)
>
>// signal函数只是注册信号的处理行为, signal函数本身不会导致阻塞
>
>// 假设我们通过signal函数注册了一个信号: signal(信号宏/信号值,  handler函数):
>// 当注册的信号触发的时候, 会执行这个handler函数, 否则不执行, 这个signal函数的注册的函数是一种回到机制
>
>// 使用同一个handler去注册不同的信号:
>// eg: (假设把2号信号和3号信号的处理函数都注册为, func函数)
>//			signal(2, func);
>//			signal(3, func);
>// 这会导致, 无论2号信号产生或者3号信号产生, 都会去执行func函数
>```
>

>```C
>信号递送过程中，产生了另一个同类信号会怎么样？产生了另两个、三个、多个同类信号会怎么样？写代码验证一下你的想法。说明mask和pending如何变化。（如果想通过代码深入论证， 需要基于我们今天提到的全程屏蔽mask的原理， 以及还没有讲的一个函数：获取当前进程‘未决信号‘的函数sigpending（可以提前看一下文档上有记录），    ）
>```
>
>```C
>// 信号递送过程中，产生了另一个同类信号, 这个同类信号并不会立即处理, 要等上一个同类信号执行完毕之后, 这个新来的同类信号才能执行.
>
>// 信号递送过程中，产生了又产生了另两个、三个、多个同类信号, 和额外产生一个同类信号最终执行结果相同, 因为在一个进程中信号是靠位图存储, 一个同类信号共用同一个bit位, 所以同时有两个或者更多的同类信号到来,改变的是同一个bit位.
>```
>
>```C
>void func(int num){
>
>    printf("signal %d begin \n", num);
>    sleep(10);
>
>    sigset_t set;
>    sigemptyset(&set);
>    sigpending(&set);
>    if(sigismember(&set, 2)){
>       printf("2号信号未决 \n");
>    }
>    sigemptyset(&set);
>    sigset_t oldset;
>    sigemptyset(&oldset);
>    // 目的: 获取当前的mask掩码状态 (通过 oldset )
>    sigprocmask(SIG_UNBLOCK, &set, &oldset);
>    if(sigismember(&oldset, 2)){
>       printf("2号信号在掩码中被设置了阻塞 \n");
>    }
>    if(sigismember(&oldset, 3)){
>       printf("3号信号在掩码中被设置了阻塞 \n");
>    }
>
>    printf("signal %d over \n", num);
>}
>int main(){
>    signal(2, func);
>
>    while(1);
>    return 0;
>}
>```
>
>```C
>// 第一次的运行结果
>^Csignal 2 begin 
>^C2号信号未决 
>2号信号在掩码中被设置了阻塞 
>signal 2 over 
>signal 2 begin 
>2号信号在掩码中被设置了阻塞 
>signal 2 over 
>
>// 第二次的运行结果 
>^Csignal 2 begin 
>2号信号在掩码中被设置了阻塞 
>signal 2 over 
>```
>
>```C
>// 通过上述第一次运行结果: 说明一个2信号正在执行的时候, 一个信号2号信号过来, 会在进程task_struct中记录信号pengding字段上中的signal所表示的位图上, 把2号信号的对应bit位标记为信号存在状态
>// 同时, 通过第一次和第二次运行结果, 我们通过获取当前mask掩码, 都发现2号信号在处理的时候, 会在mask上把2号信号对应bit位设置为阻塞状态, 用以阻塞新到来的2号信号
>```


