>编写C程序验证 "ps -elf "命令显示的是有效用户ID，还是真实用户ID。
>
>作业中应该包括代码、操作每个步骤和命令以及最终结果的截图
>
>```C
>// 验证步骤:
>// 1, 创建一个文件: test.c, 代码如下
>int main(){
>	printf("current process uid: %d \n", getuid());
>	printf("current process group uid: %d \n", getgid());
>	printf("current effective process uid: %d \n", geteuid());
>  	printf("current effective process group uid: %d \n", getegid());
>    while(1);
>        return 0;
>}
>    // 2, make命令编译生成可执行程序: test
>// 3, 修改文件权限(把这个可执行程序改为root所有): sudo chown root:root test
>    // 4, 给这个可执行程序增加S权限: sudo chmod u+s test
>    // 5, 启动这个程序: ./test   打印结果如下:
>    current process uid: 1000 
>    current process group uid: 1000 
>current effective process uid: 0 
>    current effective process group uid: 1000 
>    // 说明: 当前真实用户id为1000(就是我的账号snow),  有效用户为0(就是root账号)
>    
>    // 6, 同时, 新打开一个会话, 使用ps -elf 命令, 找到test这个进程: 显示如下
>0 R root       13870   13055 99  80   0 -   694 -      20:21 pts/0    00:01:30 ./test
>// 显示的账号为root, 说明为有效用户
>    
>```

>使用思维导图整理进程相关的命令, 以及每个命令比较重要部分的显示结果
>
>```c
>略: 主要目的是让大家再看看如下命令
>// ps -elf
>// ps -aux
>    // top
>    ```
>    

>说明什么是孤儿进程，什么是僵尸进程，他们对操作系统有什么影响？书写代码创建孤儿进程和僵尸进程。
>
>```C
>// 在操作系统中, 如果一个进程的子进程先退出，系统不会自动清理掉子进程的环境，而必须由这个父进程来完成清理工作(读取退出状态, 释放资源等 )，如果父进程不做清理工作，则已经退出的子进程将成为僵尸进程，在系统中如果存在的僵尸进程过多，将会影响系统的性能， 所以必须对僵尸进程进行处理.
>
>// 当我们的代码创建了一个子进程执行某种任务, 但是在这个子进程退出的时候,我们未调用父进程未做清理工作, 导致僵尸产生. 
>// 一般在我们书写代码和运行程序的过程中, 我们可能在一个进程中启动另外一个子进程处理一个"独立的"业务逻辑, 这种行为经常是频繁且重复的, 这也就意味着, 一旦我们因为代码疏漏,未对退出的子进程进行清理, 这可能会快速的导致接连不断的僵尸进程产生, 这些僵尸进程会随着数量变多而大量占用系统资源(尤其是内存资源, 以及进程pid的编号), 有可能导致系统资源不足, 进而影响系统的正常工作.
>```

>进程的结束方式有哪些？return、_exit和exit有什么区别？
>
>```C
>// 我们可以把进程的退出, 简单分为两类, 一种是进程正常退出流程, 一种是通过信号被动退出
>// 正常退出:
>		1, 在进程的入口函数: main函数中调用return结束main函数
>		2, 通过在进程运行的过程中, 调用exit函数退出
>		3, 通过在进程运行的过程中, 调用_exit或者_Exit函数退出       
>// 异常退出:
>		1, 收到外部的信号: (键盘输入的信号)(kill命令的信号)(...)
>		2, 自发性的信号: (当前进程程序运行中, 由于某些函数的执行过程中抛出的信号, 比如abort函数为例 )       
>```
>
>```C
>return、_exit和exit有什么区别？
>// return只能用在进程入口函数中, 才能结束进程
>// 当调用 `_exit`和`_Exit`的时候，进程会直接终止返回内核，资源清理交给内核处理.
>// 而exit函数则会首先执行终止处理程序，然后清理标准IO （就是把所有打开的流执行一次fclose ），最后再终止进程回到内核。
>```

>```C
>(1). 请问下面的程序一共输出多少个“-”
>int main()
>{
>   printf("-");  
>   fork();
>   printf("-");
>   fork();
>   return 0;
>}
>// 打印8个'-''
>(2). 上题中的printf("-")换成printf("-\n")；程序会输出多少个“-”?思考一下为什么？
>// 打印3个'-''
>```
>
>```C
>// 如果printf("-");  不加换行, 它并没有被刷新到内核的输出缓冲区, 依旧在用户态缓冲区, 这是因为行缓冲的特性
>// 所以在第一次fork拷贝的时候, 父子进程的用户态缓冲区, 同时拥有了一个'-'
>// 然后它们分别又进行了一次printf("-"); 那么, 两个进程的用户态缓冲区, 都拥有两个'-'
>// 在第二次fork的时候, 原本的父子进程, 分别又延伸出了子进程, 并且分别拷贝了它们的用户态的两个'-'
>// 这就导致四个进程, 每个进程用户态缓冲区, 都拥有两个'-'
>// 当四个进程都走到return结束的时候, 分别把自己的用户态缓冲区, 刷新到内核缓冲区, 输出打印:  2*4 = 8
>
>// 而加上'\n'之后, 每次执行printf("-\n"); 会立即刷新打印.就不会产生复制的时候在用户态有遗留的'-'的问题了
>```

>书写两个可执行程序：
>
>可执行程序一：
>
>  父进程负责创建子进程并且最后回收其资源；
>
>  子进程加载可执行程序二。
>
>可执行程序二：
>
>  列出当前目录所有文件的文件名。
>
>```C
>// 可执行程序2:  ls.c
>int main(int argc,char*argv[])
>{
>    system("ls");
>    return 0;
>}
>```
>
>```C
>// 可执行程序1:
>
>int main(int argc,char*argv[])
>{
>
>    if(fork() == 0){
>        execl("./ls", "./ls", (char *)0);
>    }else{
>        wait(NULL);
>    }
>    return 0;
>}
>```
