>使用epoll实现一个基于TCP即时聊天，服务端需要支持断线重连。
>
>```C
>// 客户端
>int main(){
>
>    // 服务端的端口和ip
>    char *ip = "192.168.106.130";
>    char *port = "8080";
>    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;
>    sockaddr.sin_port = htons(atoi(port)); 
>    sockaddr.sin_addr.s_addr = inet_addr(ip);
>    connect(socket_fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr) );
>
>    // 创建epoll对象
>    int epoll_fd = epoll_create(1);
>    // 放入监听: 把stdin放入监听, 并且监听stdin的读事件
>    struct epoll_event event;
>    event.data.fd = STDIN_FILENO;
>    event.events = EPOLLIN;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
>
>    // 把socket_fd: 放入epoll监听,  监听读
>    event.data.fd = socket_fd;
>    event.events = EPOLLIN;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event);
>
>    int flag = 0;
>    while(1){
>        // 定义一个用来接收epoll_wait就绪的文件描述符的集合的数组
>        struct epoll_event  list[10];
>        int epoll_num = epoll_wait(epoll_fd,list, 10, -1);
>
>        for(int i=0; i<epoll_num; i++ ){
>
>          // 判断是不是标准输入可读
>             if(list[i].data.fd == STDIN_FILENO){
>              char buf[60] = {0};
>                 read(STDIN_FILENO, buf, sizeof(buf));
>                 send(socket_fd, buf, sizeof(buf), 0);
>          }
>   
>          // socket_fd是否可读
>             if(list[i].data.fd == socket_fd){
>                 // socket对象可读
>              char buf[60] = {0};
>                 int recv_ret = recv(socket_fd, buf, sizeof(buf), 0);
>              if(recv_ret == 0){
>                       printf("对端关闭 \n");
>                       flag = 1;
>                       break;
>                   }
>                   printf("buf: %s \n", buf);
>               }
>        }
>     
>             if(flag == 1){
>               break;
>             }
>         }
>         close(socket_fd);
>         return 0;
>     }
>     ```
>     
>     ```C
>// 服务端
>     
>   int main(){
>
>       char *ip = "192.168.106.130";
>         char *port = "8080";
>       int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
>
>    int num = 1;
>    setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &num, sizeof(num));
>
>    struct sockaddr_in sockaddr;
>    sockaddr.sin_family = AF_INET;// ipv4
>    sockaddr.sin_port = htons(atoi(port));// 字符串->int->大端16位
>    sockaddr.sin_addr.s_addr = inet_addr(ip);// 点分十进制字符串 -> 十进制, 大端
>    bind(socket_fd,  (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>
>    //启动对端口的监听
>    listen(socket_fd,  10);
>
>    // 创建epoll对象
>    int epoll_fd = epoll_create(1);
>
>    struct epoll_event event;
>    event.data.fd = socket_fd;
>    event.events = EPOLLIN;
>    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event);
>
>    int net_fd ;
>    while(1){
>        struct epoll_event  list[10];
>        int epoll_num = epoll_wait(epoll_fd,list, 10, -1);
>
>        for(int i=0; i<epoll_num; i++ ){
>          if(socket_fd == list[i].data.fd ){
>              // 意味着用来三次握手的socket对象可读
>              // -> 有新链接进来
>              // 从全连接队列中获取一个三次握手完毕的信息
>              // 创建socket对象, "专门用来和某个"客户端进行通信
>              net_fd = accept(socket_fd,NULL, NULL);
>
>              // 要和新链接进行通信
>              // -> 监听net_fd, 监听stdin
>              // 放入监听: 把stdin放入监听件
>              struct epoll_event event;
>              event.data.fd = STDIN_FILENO;
>              event.events = EPOLLIN;
>              epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &event);
>
>              // 把socket_fd: 放入epoll监听
>              event.data.fd = net_fd;
>              event.events = EPOLLIN;
>              epoll_ctl(epoll_fd, EPOLL_CTL_ADD, net_fd, &event);
>
>              // 不在想监听原本用来三次握手的socket对象
>              epoll_ctl(epoll_fd, EPOLL_CTL_DEL, socket_fd, NULL);
>
>                 continue;
>             }
>             // 判断是不是标准输入可读
>          if(list[i].data.fd == STDIN_FILENO){
>                 char buf[60] = {0};
>              read(STDIN_FILENO, buf, sizeof(buf));
>                 send(socket_fd, buf, sizeof(buf), 0);
>          }
>     
>               if(list[i].data.fd == net_fd){
>     
>                   char buf[60] = {0};
>                   int recv_ret = recv(net_fd, buf, sizeof(buf), 0);
>                   if(recv_ret == 0){
>                  printf("对端关闭 \n");
>                       // -> 不需要当前的net_fd所对应的socket对象
>                       // -> 不需要标准输入
>                       // -> 需要监听有没有新链接: socket_fd
>                       epoll_ctl(epoll_fd, EPOLL_CTL_DEL, net_fd, NULL);
>                       epoll_ctl(epoll_fd, EPOLL_CTL_DEL, STDIN_FILENO, NULL);
>     
>                       struct epoll_event event;
>                  event.data.fd = socket_fd;
>                  event.events = EPOLLIN;
>                       epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &event);
>                       continue;
>                   }
>                   printf("buf: %s \n", buf);
>          }
>             }
>         }
>
>         close(net_fd);
>         close(socket_fd);
>     
>         return 0;
>     }
>     ```