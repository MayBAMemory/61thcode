>根据域名，获取一下知名互联网厂商的IP地址信息，如阿里、京东、腾讯、百度。
>
>```C
>
>int main(int argc,char*argv[])
>{
>    struct addrinfo *info;
>    getaddrinfo("www.baidu.com", NULL, NULL, &info);
>	//getaddrinfo("www.taobao.com", NULL, NULL, &info);
>    
>    for(struct addrinfo *p = info; p != NULL; p = p->ai_next ){
>        if(p->ai_family == AF_INET){
>            // ipv4
>            struct sockaddr *sockaddr = p-> ai_addr;
>            struct sockaddr_in *sockaddin = (struct sockaddr_in *) sockaddr;
>            struct in_addr addr = sockaddin->sin_addr;
>
>            char *str = inet_ntoa(addr);  
>            printf("ip : %s \n", str);
>        }
>    }
>    return 0;
>}
>```

>先简单说说socket、bind、listen、accept、connect函数分别有什么基本作用呢？
>
>```C
>
>// socket: socket函数用来创建一个socket对象, 这个对象中包含一些基本的进行网络通信所需要的各种信息和状态
>// bind: 无论式客户端还是服务器(一般给服务器使用), 都可以通过bind绑定一个用于通信的的端口以及IP地址
>// listen: 当服务器使用listen函数, 可以让服务器根据预设的(bind设置)的端口, 进行通信的监听行为, 监听有没有连接到来
>// connect: 一般由客户端调用, 当connect函数被调用, 当前内核就会促使当前socket对象组织TCP数据段发起三次握手请求, 当connect函数正常成功返回, 则代表通过三次握手, 和服务器间建立了一个TCP通信连接
>```

>使用recv和send函数时发生了什么？
>
>```C
>// send函数的作用是当程序调用send的时候, send函数会把提供给send函数的数据从用户态拷贝到对应的内核态socket对象的输出缓冲区中( 然后后续, 操作系统会把这个socket对象的输出缓冲区的数据拷贝的网卡发送走 )
>// recv函数, 是从指定的内核态的socket对象的输入缓冲区中, 拷贝数据到用户态.
>```

>使用select编写聊天室程序：
>
>客户端和服务端使用tcp通信；
>
>服务端可以处理新客户端的连接和转发消息；
>
>客户端可以连入服务端并发送消息。
>
>```C
>// 聊天室客户端
>int main(int argc,char*argv[])
>{
>// 启动socket函数, 获得对应的socket_fd描述符
>int sofd = socket(AF_INET, SOCK_STREAM, 0);
>
>// 创建服务端的地址和端口
>struct sockaddr_in sockaddr;
>sockaddr.sin_family = AF_INET;
>sockaddr.sin_addr.s_addr = inet_addr("192.168.106.129");
>sockaddr.sin_port = htons(atoi("8080"));
>
>// 建立socket链接
>connect(sofd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>
>// 构建select监听的集合: fd_set类型
>fd_set set;
>// 清空set: 初始化set
>FD_ZERO(&set);
>
>while(1){
>  // 添加socket监听
>  FD_SET(sofd, &set);
>  // 添加标准输入监听集合
>  FD_SET(STDIN_FILENO, &set);
>  // select开始监听有没有就绪事件
>  select(10, &set, NULL, NULL, NULL);
>  
>  // 判断标准输入是否就绪
>  if(FD_ISSET(STDIN_FILENO, &set)){
>      // 读取标准输入
>      char buf[60] = {0};
>      int res_read = read(STDIN_FILENO, buf, sizeof(buf));
>      // 用户输入EOF(Ctrl+D), 准备挂断链接
>      if(res_read == 0){
>          printf("已退出群聊 \n");
>          break;
>      }
>      // 把读取的标准输入, 发送给服务器
>      send(sofd, buf, sizeof(buf), 0);
>  }
>  // 判断是否有socket数据达到:即socket就绪
>  if(FD_ISSET(sofd, &set)){
>      char buf[60] = {0};
>      // 从socket的缓冲区中, 读取到达数据
>      int res_recv = recv(sofd, buf, sizeof(buf), 0);
>      // 如果recv返回值为0, 表示对方断开链接
>      if(res_recv == 0){
>          printf("--服务器断开链接OR服务端踢出链接------");
>          break;
>      }
>      // 打印读取的数据到控制台
>      printf("msg: %s \n", buf);
>  }
>}
>close(sofd);
>return 0;
>}
>```
>
>```C
>// 聊天室服务端
>typedef struct conn_s{
>int netfd;
>int isalive;
>} conn_t;
>
>int main(int argc,char*argv[])
>{
>// 启动socket函数, 获得对应的socket_fd描述符
>int sofd = socket(AF_INET, SOCK_STREAM, 0);
>
>// 创建服务端的地址和端口
>struct sockaddr_in sockaddr;
>sockaddr.sin_family = AF_INET;
>sockaddr.sin_addr.s_addr = inet_addr("192.168.106.129");
>sockaddr.sin_port = htons(atoi("8080"));
>
>// 绑定端口ip
>bind(sofd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));
>// 监听端口
>listen(sofd, 10);
>
>// 构建select监听的集合: fd_set类型
>fd_set set;
>// 清空set: 初始化set
>FD_ZERO(&set);
>FD_SET(sofd, &set);
>
>// 客户端数组: 用于保存所有链接服务器的客户端
>conn_t list[1024] ;
>memset(list, 0 , sizeof(list));
>// 客户端的存在个数
>int index;
>
>while(1){
>  // 构建此次的监听集合
>  fd_set temp_set;
>  // 把set记录复制到本次监听集合
>  memcpy(&temp_set, &set, sizeof(set));
>  
>  // select开始监听有没有就绪事件
>  select(10, &temp_set, NULL, NULL, NULL);
>
>  // 判断是否有socket数据达到:即socket就绪
>  if(FD_ISSET(sofd, &temp_set)){
>      // 获得一个新的客户端链接
>      int netfd = accept(sofd, NULL, NULL);
>      // 保存到""客户端""链接数组中
>      list[index].isalive = 1;
>      list[index].netfd = netfd;
>      // 下一次增加监听这个客户端
>      FD_SET(netfd, &set);
>      
>      index++;
>  }
>  // 遍历客户端列表 
>  for(int i=0; i<index; i++){
>      // 当前遍历的客户端
>      conn_t con = list[i];
>      // 判断这个客户端是否存活, 以及是否就绪: 即是否有消息到来
>      if(con.isalive == 1 && FD_ISSET(con.netfd, &temp_set)){
>          // 该客户端存活, 且处于就绪状态
>          // 读取客户端的到达信息
>          char buf[60] = {0};
>          int res_recv = recv(con.netfd, buf, sizeof(buf), 0);
>          // 如果返回值为0, 说明这个客户端已经断开
>          if(res_recv == 0){
>              // 把客户端数组中该标记置为0: 即非存活状态
>              list[i].isalive = 0;
>              // 取消后续对次客户端的select监控
>              FD_CLR(con.netfd, &set);
>              // 关闭这个客户端
>              close(list[i].netfd);
>          }else{
>              // 把读取到的数据, 分发给别的客户端
>              // 遍历所有客户端
>              for(int j=0; j<index; j++){
>                  if(list[j].isalive == 0|| j == i){
>                      // 跳过断开链接的客户端, 跳过发信息过来的客户端
>                      continue;
>                  }
>                  // 发送信息
>                  send(list[j].netfd, buf, sizeof(buf), 0);
>              }
>          }
>      }
>
>  }
>}
>close(sofd);
>return 0;
>}
>```