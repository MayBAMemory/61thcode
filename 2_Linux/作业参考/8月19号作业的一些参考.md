>什么是线程？线程和进程有哪些区别？
>
>```C
>线程操作系统在进程的基础上划分的一个更小的程序执行单元, 线程是依赖于进程而存在, 一个进程中包含多个线程, 在一个进程中的多个线程共享一个进程的代码段、数据段、堆空间, 同时每一个线程都维护了一个自己的栈空间, 这也使得操作系统在一个进程中调度不同线程执行任务的时候(现在的操作系统调度的基本单位已经是线程了)需要更小的系统开销, 这是因为操作系统能以更快的速度将更小的程序运行上下文保存.
>在使用上进程具有更好的解耦性, 两个进程的内存从逻辑上是相互独立没有关联的.这也就使得一个进程的崩溃不容易波及到别的进程; 在线程的设计上由于一个进程的多个线程是共享进程的内存的, 这可能导致一个线程的崩溃波及到同进程中的别的线程.
>```

>线程的清理函数什么时候会执行？什么情况下线程退出的时候不会执行清理函数？
>
>```C
>当线程在运行的过程中, 遇到pthread_exit导致线程退出, 在退出线程之前, 会使当前所在线程弹出函数清理栈中预设的回调函数并执行.
>当线程在运行过程中, 如果别的线程通过pthread_cancel函数要求当前线程退出, 修改了当前线程的退出标记, 而当前线程在走到取消点函数的时候检测退出标记发现需要结束线程, 在线程结束之前,会使函数清理栈弹栈, 并执行其中弹栈的回调函数.
>当线程在其入口函数通过return退出的时候, 函数清理栈中的清理函数不会执行.
>如果我们从来没有试图向函数清理栈中预设回调函数, 那么线程在退出的时候也不会执行清理函数
>```

>从源码角度说明为什么`pthread_cleanup_push`和`pthread_cleanup_pop`必须成对出现？
>
>```C
>// 源码
>#  define pthread_cleanup_push(routine, arg) \
>       do {                                        \
>         __pthread_cleanup_class __clframe (routine, arg)
>#  define pthread_cleanup_pop(execute) \
>         __clframe.__setdoit (execute);                        \
>       } while (0)
>// 以上述源码为例, pthread_cleanup_push和pthread_cleanup_pop函数只有一起出现才能构建出一个完整的do-while结构
>```

>尝试使用2个线程对同一个全局变量各加2000万(或者更多次)，统计加锁解锁的消耗。使用gettimeofday可以获取高精度当前时间
>
>```C
>// 定义一个锁
>pthread_mutex_t lock;
>
>int num = 0;
>
>void *func(void *p){
>
>        for(int i=0; i<10000000; i++){
>            pthread_mutex_lock(&lock);
>            num++;
>            pthread_mutex_unlock(&lock);
>        }
>
>        return NULL;
>}
>int main(){
>
>        struct timeval beginTime, endTime;
>        gettimeofday(&beginTime, NULL);
>
>        pthread_mutex_init(&lock,  NULL);
>
>        pthread_t son_id;
>        pthread_create(&son_id, NULL, func, NULL);
>
>        for(int i=0; i<10000000; i++){
>            pthread_mutex_lock(&lock);
>            num++;
>            pthread_mutex_unlock(&lock);
>        }
>
>        pthread_join(son_id, NULL);
>        printf("num: %d \n", num);
>
>
>        gettimeofday(&endTime, NULL);
>
>        printf("time: %ld  us \n", endTime.tv_usec - beginTime.tv_usec + (endTime.tv_sec - beginTime.tv_sec)*1000000);
>
>        pthread_mutex_destroy(&lock);
>        return 0;
>}
>```

>书写程序，创建3个子线程，然后等待所有的子线程终止，最后还要获取其退出状态。
>
>```C
>void *fun1(void *p){
>
>        long num = 10;
>        return (void *)num;
>}
>void *fun2(void *p){
>        void *str = malloc(20);
>        strcpy((char *)str, "son2");
>        return str;
>}
>void *fun3(void *p){
>
>        return NULL;
>}
>int main(){
>
>        pthread_t son1_id, son2_id, son3_id;
>        pthread_create(&son1_id, NULL, fun1, NULL);
>        pthread_create(&son2_id, NULL, fun2, NULL);
>        pthread_create(&son3_id, NULL, fun3, NULL);
>
>        void * ret1;
>        void * ret2;
>        void * ret3;
>        pthread_join(son1_id, &ret1);
>        pthread_join(son2_id, &ret2);
>        pthread_join(son3_id, &ret3);
>
>        printf("ret1: %ld \n",(long)ret1 );
>        printf("ret2: %s \n",(char *)ret2 );
>        printf("ret3: %s \n",(char *)ret3 );
>    	free(ret2);
>        return 0;
>}
>```

>```C
>使用多线程模拟卖票逻辑:
>// 一个线程卖票:(总票数num--即为卖票) 票未必每一次都能卖掉, 每一次买票的人在随机的状态下(假设:用产生一个随机数<0.5表示有人要买票)选择是否买票 (即产生随机数:导致num--)
>// 另一个线程加票
>// 在初始情况下有20张票的情况下:每次(如果能卖掉)卖一张
>// 当第一次票小于5张的时候追加一次票(假设暂时只追加一次票): 10张票// 卖完为止
>```
>
>```C
>#include <testfun.h>
>typedef struct share_state{
>        int flag; // 0: 未加票, 1已加票 
>        int ticketNum;
>        pthread_mutex_t mLock;
>} share_state_t;
>
>void *sellFun(void *arg){
>        share_state_t *pShareState = (share_state_t *)arg;
>
>        while(1){
>           pthread_mutex_lock(&pShareState->mLock);
>
>           if(pShareState->ticketNum <= 0 && pShareState->flag == 1){
>               pthread_mutex_unlock(&pShareState->mLock);
>               break;
>           }
>
>           struct timeval nowTime;
>           gettimeofday(&nowTime, NULL);
>           srand((unsigned int) nowTime.tv_usec );
>           double rand_num = (double)rand()/RAND_MAX;
>
>           if(pShareState->ticketNum > 0 && rand_num < 0.1){
>               pShareState->ticketNum--;
>               printf("ticketNum = %d \n", pShareState->ticketNum);
>           }
>           pthread_mutex_unlock(&pShareState->mLock);
>        }
>}
>void *purchaseFun(void *arg){
>        share_state_t *pShareState = (share_state_t *)arg;
>
>        while(1){
>           pthread_mutex_lock(&pShareState->mLock);
>
>           if(pShareState->ticketNum <= 5){
>               pShareState->ticketNum = pShareState->ticketNum + 10;
>               pShareState->flag = 1;
>               pthread_mutex_unlock(&pShareState->mLock);
>               break;
>           } 
>
>           pthread_mutex_unlock(&pShareState->mLock);
>        }
>}
>int main(int argc,char*argv[])
>{
>        share_state_t shareState;
>        shareState.ticketNum = 20;
>        shareState.flag = 0;
>        pthread_mutex_init(&shareState.mLock, NULL);
>
>        pthread_t pid1, pid2;
>        pthread_create(&pid2,NULL,purchaseFun,&shareState);
>        pthread_create(&pid1,NULL,sellFun,&shareState);
>
>        pthread_join(pid1, NULL);
>        pthread_join(pid2, NULL);
>        return 0;
>}
>```
>
