>```C
>主线程执行事件A
>A:
>   printf("Before A!\n");
>   sleep(3)
>   printf("After A\n");
>子线程执行事件B，
>B:
>   printf("Before B!\n");
>   sleep(3)
>   printf("After B\n");
>在AB事件之外不使用sleep，使用条件变量，确保B一定在A完成之后运行。
>```
>
>```C
>pthread_mutex_t lock;
>pthread_cond_t cond;
>int flag = 0 ;// 标记A有没有已经打印
>
>void *func(void *p){
>    
>        pthread_mutex_lock(&lock);
>         if(flag == 0){
>            pthread_cond_wait(&cond, &lock);
>         }
>         pthread_mutex_unlock(&lock);
>         printf("Befor B \n");
>         sleep(3);
>        printf("After B \n");
>     
>         return NULL;
>     }
>     int main(int argc,char*argv[])
>     {
>         pthread_mutex_init(&lock, NULL);
>        pthread_cond_init(&cond, NULL);
>        pthread_t son_id;
>    pthread_create(&son_id, NULL, func, NULL);
>
>    printf("Befor A \n");
>        sleep(3);
>        printf("After A \n");
>     
>         pthread_mutex_lock(&lock);
>         flag = 1;
>         pthread_cond_signal(&cond);
>         pthread_mutex_unlock(&lock);
>     
>        pthread_join(son_id, NULL);
>         pthread_mutex_destroy(&lock);
>         pthread_cond_destroy(&cond);
>         return 0;
>     }
>    ```

>```C
>现在有两个线程t1和t2，t1 打印 A 和 C，t2 打印 B。书写代码，使用条件变量每次的显示顺序都是A->B->C。
>
>代码书写完成后，回答问题：条件变量中加锁的目的是什么？
>```
>
>```C
>pthread_mutex_t my_lock;
>pthread_cond_t cond;
>int flag = 0; // 某个线程检测flag==0, 说明自己先上线的
>
>void * funcAC(void *p){
>    pthread_mutex_lock(&my_lock);
>    if(flag == 0){
>       // 假设AC先执行
>       flag = 1;
>       printf("A \n");
>       pthread_cond_wait(&cond, &my_lock);
>       printf("C \n");
>       pthread_mutex_unlock(&my_lock);
>    }else{
>       // B先运行
>       printf("A \n");
>       pthread_cond_signal(&cond);
>       pthread_cond_wait(&cond, &my_lock);
>       printf("C \n");
>       pthread_mutex_unlock(&my_lock);
>    }
>    return NULL;
>}
>void * funcB(void *p){
>
>    pthread_mutex_lock(&my_lock);
>    if(flag == 0){
>       // B先上线获取锁
>       flag = 1;
>       pthread_cond_wait(&cond, &my_lock);
>       printf("B \n");
>       pthread_cond_signal(&cond);
>       pthread_mutex_unlock(&my_lock);
>    }else{
>       // AC先上线, B后执行
>       printf("B \n");
>       pthread_cond_signal(&cond);
>       pthread_mutex_unlock(&my_lock);
>    }
>
>    return NULL;
>}
>int main(int argc,char*argv[])
>{
>    pthread_mutex_init(&my_lock, NULL);
>    pthread_cond_init(&cond, NULL);
>
>    pthread_t sonac, sonb;
>    pthread_create(&sonac, NULL, funcAC, NULL);
>    pthread_create(&sonb, NULL, funcB, NULL);
>
>    pthread_join(sonac, NULL);
>    pthread_join(sonb, NULL);
>
>    pthread_mutex_destroy(&my_lock);
>    pthread_cond_destroy(&cond);
>    return 0;
>}
>```

