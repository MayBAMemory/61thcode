>实现即时聊天，如果对方连续10s没有发送任何消息则断开连接。（注意，即使本方在10s内从标准输入当中输入数据也不行）。
>
>```C
>int main(int argc,char*argv[])
>{
>   int fd_write = open("1.pipe", O_WRONLY);
>   int fd_read = open("2.pipe", O_RDONLY);
>   char buf[60];
>
>   fd_set set;
>
>   // 记录a发过来信息的时间
>   time_t tag_a_msg = time(NULL);
>   // 记录当前时间
>   time_t tag_cur = time(NULL);
>
>   while(1){
>       FD_ZERO(&set);
>       FD_SET(STDIN_FILENO, &set);
>       FD_SET(fd_read, &set);
>
>       // 每1秒就绪一次
>       struct timeval time_val;
>       time_val.tv_sec = 1;
>       time_val.tv_usec = 0;
>       int res_select = select(10, &set, NULL,NULL, &time_val);
>       // 更新当前时间
>       tag_cur = time(NULL);
>
>       if(FD_ISSET(fd_read, &set)){
>           bzero(buf, sizeof(buf));
>           int read_num = read(fd_read, buf, sizeof(buf));
>           if(read_num == 0){
>               printf("对方断开链接 \n");
>               break;
>           }
>           printf("UserA: %s", buf);
>           // 更新a的发送信息时间
>           tag_a_msg = time(NULL);
>       }
>       if(FD_ISSET(STDIN_FILENO, &set)){
>           bzero(buf, sizeof(buf));
>           int read_stdin = read(STDIN_FILENO, buf, sizeof(buf));
>           if(read_stdin == 0){
>               // 用户按下ctrl+d; 输入文件终止符; 终止标准输入; read返回0
>               break;
>           }
>           write(fd_write, buf, sizeof(buf));
>       }
>       // 比较信息时间和当前时间
>       if(tag_cur - tag_a_msg >= 10){
>           printf("10秒未发信息 \n");
>           break;
>       }
>   }
>   close(fd_write);
>   close(fd_read);
>   return 0;
>}
>```

>编写程序A和B。A负责将文件的名字、长度和内容通过管道发送B，B需要新建一个目录，并将该文件存储起来。
>
>```c
>// A
>int main(int argc,char*argv[])
>{
>   int pipe_fd = open("1.pipe", O_WRONLY);
>
>   char* name = "test1.txt";
>   int file_lenth = 10;
>   char* str = "helloworld";
>
>   int name_length = strlen(name);
>   write(pipe_fd, &name_length, sizeof(int));
>   write(pipe_fd, name, name_length);
>
>   write(pipe_fd, &file_lenth, sizeof(int));
>
>   int str_length = strlen(str);
>   write(pipe_fd, &str_length, sizeof(int));
>   write(pipe_fd, str, str_length);
>
>   return 0;
>}
>```
>
>```C
>// B
>int main(int argc,char*argv[])
>{
>   int pipe_fd = open("1.pipe", O_RDONLY);
>
>   // 先读取文件名长度, 再根据文件名长度读取文件名
>   int name_length = 0;
>   read(pipe_fd, &name_length, sizeof(int));
>   char file_name[60] = {0};
>   read(pipe_fd, file_name, name_length);
>
>   // 读取文件长度
>   int file_length = 0;
>   read(pipe_fd, &file_length, sizeof(int));
>
>   // 先读取文件内容长度, 再根据内容长度读取要写入文件的内容
>   int  str_length = 0;
>   read(pipe_fd, &str_length, sizeof(int));
>   char str_buf[60] = {0};
>   read(pipe_fd, str_buf, str_length);
>
>   // 创建文件夹, 修改当前工作路径
>   mkdir("files", 0777);
>   chdir("files");
>   // 根据文件名创建文件
>   int new_fd = open(file_name, O_RDWR|O_CREAT, 0664);
>   // 修改文件大小
>   ftruncate(new_fd, file_length);
>   // 向文件中写入内容
>   write(new_fd, str_buf, str_length);
>
>   return 0;
>}
>```

>书写一个程序同时监听管道的读端和写端。
>
>- 如果可写，则写入4096个字节
>- 如果可读，则读取1024个字节
>
>描述一下运行的现象
>
>```C
>#include <57header.h>
>
>int main(int argc,char*argv[])
>{
>int pipe_fd = open("1.pipe", O_RDWR);
>
>fd_set set_read;
>fd_set set_write;
>FD_ZERO(&set_read);
>FD_ZERO(&set_write);
>
>while(1){
>FD_SET(pipe_fd, &set_read);
>FD_SET(pipe_fd, &set_write);
>select(10,&set_read, &set_write, NULL, NULL);
>
>if(FD_ISSET(pipe_fd, &set_write)){
>  char buf[4096] = {0};
>  write(pipe_fd, buf, sizeof(buf));
>  printf("write once \n");
>}
>if(FD_ISSET(pipe_fd, &set_read)){
>  char buf[1024] = {0};
>  read(pipe_fd, buf, sizeof(buf));
>  printf("read once \n");
>}
>
>sleep(1);
>}
>
>close(pipe_fd);
>return 0;
>}
>// 执行的结果: 
>write once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>write once 
>read once 
>read once 
>write once 
>read once 
>read once 
>read once 
>read once 
>write once 
>read once 
>read once 
>read once 
>read once 
>// 第一次循环:  管道为空,所以可写; 管道没有数据,不可读
>// 第二次循环<->其后的多次循环: 管道不满, 可以写; 管道有数据, 所以可读
>上面操作, 写快(每次写4096), 读慢(每次读1024)
>// 当某次循环: 管道写满, 不再可写; 管道有数据, 可读
>//            可读
>//            可读
>//            可读
>//  读了一些空间出来, 有变得可写, 可读
>//  写满, 不可写, 可读
>//            可读
>//            可读
>//            可读
>//  读了一些空间出来, 有变得可写, 可读
>//  写满, 不可写, 可读
>//            可读
>//            可读
>//            可读
>// ....
>```

