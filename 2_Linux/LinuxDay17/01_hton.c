#include <header.h>
//  高字节存低地址: 大端法
//  低字节存低地址: 小端法
//  htonl: 主机->网络;  小端->大端
//  ntohl: 网络->主机;  大端->小端
int main()
{
   // int 4字节, 字节位从高到底分别为:  0x75,  0x76, 0x77, 0x78
   // 因为主机采用小端法, 低字节/低位  -> 低地址
   // 所以: 按照地址从低到高, 依次存储: 0x78, 0x77, 0x76, 0x75 
   int num = 0x75767778;

   // &num: 取地址, 取的是首地址/低地址, 即0x78的地址
   // 把存储了0x78的地址, 用*c保存, *c指向了0x78
   char *c = (char *) &num;
   // 打印0x78, 按照字符打印;  我们知道0x78 对应的二进制为0111 1000 十进制即120,   而字符x所对应的ascii码值为120, 所以打印x
   printf("the first char : %c \n", *c);

   // htonl: 可以把主机顺序转化为网络序;  即小端转大端
   // 如果按照大端存储 0x75767778, 即高数字/字节位存小地址/低地址,  则按照地址从低到高, 依次存储0x75, 0x76, 0x77, 0x78 
   int res = htonl(num);
   // &res, 代表数字的首地址/低地址,  而低地址的第一个字节存储的是 0x75 
   // 等价于*c2, 指向0x75所在的字节
   char *c2 = (char *) &res;
   // 已知0x75的二进制为 0111 0101, 十进制为117,  117对应的ascii为u,  所以按照字符打印0x75,打印出来的是字符u
   printf("the first char : %c \n", *c2);

   return 0;
}
